.include "T.dom"                         # domain of types
.include "M.dom"                         # domain of methods
.include "V.dom"                         # domain of variables
.include "I.dom"                         # domain of invoke statements
.include "EH.dom"                        # domain of exception handlers
.include "P.dom"                         # domain of program points
.include "H.dom"                         # domain of allocation sites 


relT(t:T) input
relM(m:M) input
relV(v:V) input
relI(i:I) input
relEH(eh:EH) input
relP(p:P) input
relH(h:H) input

ExceptionType(t:T) input                 # Type t is an exception type
sub(t:T,t1:T) input                      # Type t is a subtype of type t1
HasThrow(eh:EH,p:P) input                # Catch block eh contains throw statement p
MEH(m:M,eh:EH) input                     # Method m contains exception handler eh (exception handler and catch block: both are the same)
ThrowPV(m:M,p:P,v:V) input               # Instruction p of method m throws variable v
VarEH(eh:EH,v:V) input                   # Variable v is the variable of the catch block eh
VT(v:V,t:T) input                        # Variable v has type t.
HT(h:H,t:T) input
VCatchesH(v:V,h:H) input
VH(v:V,h:H) input
WrapsEx(h2:H,h1:H) input

ThrowEH(eh:EH,m:M,v:V)
MVarEH(m:M,eh:EH,v:V)
TransSub(t1:T,t2:T)
ValidExType(v:V,t1:T)
ThrowSub(m:M,v:V)
ThrowPt1(m:M,p:P,v:V)
ThrowPt2(m:M,p:P,v:V)
ThrowPt3(m:M,p:P,v:V)
ThrowPt4(m:M,p:P,v:V)
ThrowUnion(m:M,p:P,v:V)
ThrowSubsumed(eh:EH,m:M,p:P,v:V)

ThrowRemaining(m:M,p:P,v:V) printtuples
ThrowOrigin(m:M,p:P,v:V) printtuples
LinkedEx(m1:M,v1:V,t1:T,m2:M,v2:V,t2:T) printtuples


# Rules

# Find "throw" statements within the lexical scope of a catch block
ThrowEH(eh,m,v) :- HasThrow(eh,p), MEH(m,eh), ThrowPV(m,p,v).

# Find links between a catch variable and a subsumed-throw variable such that 
# they have types t1 and t2 respectively, and it is potentially possible for
#   1) them to point to the same exception object, or
#   2) them to point to exception objects that wrap one within the other.

MVarEH(m,eh,v) :- MEH(m,eh), VarEH(eh,v).
TransSub(t1,t2) :- sub(t1,t2), ExceptionType(t2), ExceptionType(t1).
TransSub(t1,t2) :- sub(t1,t), TransSub(t,t2), ExceptionType(t1).
ValidExType(v,t1) :- VT(v,t), TransSub(t1,t).
LinkedEx(m,v1,t1,m,v2,t2) :- MVarEH(m,eh,v1), ThrowEH(eh,m,v2), ValidExType(v1,t1), ValidExType(v2,t2).

ThrowSubsumed(eh,m,p,v) :- LinkedEx(m1,v1,t1,m,v,t), ThrowPV(m,p,v), VarEH(eh,v1).
ThrowSub(m,v) :- ThrowSubsumed(eh,m,p,v).
ThrowOrigin(m,p,v) :- ThrowPV(m,p,v), !ThrowSub(m,v).

######################################################################################
# We need to compute this:
# ThrowRemaining - the throw statements for which we have no further explanation.
######################################################################################

ThrowPt1(m,p,v) :- ThrowOrigin(m,p,v).
ThrowPt2(m,p,v) :- ThrowSubsumed(eh,m,p,v), VH(v,h), WrapsEx(h,h1), VarEH(eh,ehv), VCatchesH(ehv,h1). # wrap and throw
ThrowPt3(m,p,v) :- ThrowSubsumed(eh,m,p,v), VH(v,h1), WrapsEx(h,h1), VarEH(eh,ehv), VCatchesH(ehv,h). # unwrap and throw
ThrowPt4(m,p,v) :- ThrowSubsumed(eh,m,p,v), VH(v,h), VarEH(eh,ehv), VCatchesH(ehv,h).  # rethrow
ThrowUnion(m,p,v) :- ThrowPt1(m,p,v).
ThrowUnion(m,p,v) :- ThrowPt2(m,p,v).
ThrowUnion(m,p,v) :- ThrowPt3(m,p,v).
ThrowUnion(m,p,v) :- ThrowPt4(m,p,v).
ThrowRemaining(m,p,v) :- !ThrowUnion(m,p,v), ThrowPV(m,p,v).


.include "relT.datalog"
.include "relM.datalog"
.include "relV.datalog"
.include "relI.datalog"
.include "relEH.datalog"
.include "relP.datalog"
.include "relH.datalog"
.include "ExceptionType.datalog"
.include "HasThrow.datalog"
.include "MEH.datalog"
.include "ThrowPV.datalog"
.include "VarEH.datalog"
.include "VT.datalog"
.include "sub.datalog"
.include "HT.datalog"
.include "VCatchesH.datalog"
.include "VH.datalog"
.include "WrapsEx.datalog"
