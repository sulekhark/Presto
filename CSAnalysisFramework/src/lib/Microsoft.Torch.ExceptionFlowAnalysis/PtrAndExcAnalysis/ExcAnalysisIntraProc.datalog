.include "T.dom"                         # domain of types
.include "EH.dom"                        # domain of exception handlers
.include "P.dom"                         # domain of program points


# Input Relations

sub(t1:T,t2:T) input                     # Type t1 is a subtype of Type t2
InRange(eh:EH,p:P) input                 # An exception raised at Program point P could potentially be caught by ExceptionHandler eh
PrevEH(eh1:EH,eh2:EH) input              # ExceptionHandler eh1 immediately precedes eh2
TypeEH(eh:EH,t:T) input                  # ExceptionHandler eh handles exceptions of Type t
VarEH(eh:EH,v:V)  input                  # ExceptionHandler eh has the formal paramter as Variable v
ThrowPV(p:P,v:V)  input                  # Instruction p throws Variable v


# Intermediate/Output relations
BeforeEH(eh1:EH,eh2:EH)                  # Transitive closure of PrevEH
PossibleEH(eh:EH.t:T,p:P)                # If the instruction at Program point p throws an exception of Type t, ExceptionHAndler eh may catch it.
                                         # Ignores order of the catch blocks.
InfeasibleEH(eh:EH,t:T,p:P)              # It is infeasible for ExceptionHandler eh to catch an exception of Type t thrown at Program point p because
                                         # of ordering i.e. some earlier catch block is catching exceptions of the same type.
FinalEH(eh:EH,t:T,p:P)  printtuples      # ExceptionHandler eh catches an exception of Type t thrown at Program point p.


#Rules
PossibleEH(eh,t,p) :- InRange(eh,p), TypeEH(eh,t).
PossibleEH(eh,s,p) :- Possible(eh,t,p), sub(s,t).
BeforeEH(eh1,eh2) :- PrevEH(eh1,eh2).
BeforeEH(eh1,eh3) :- BeforeEH(eh1,eh2), PrevEH(eh2,eh3).
InfeasibleEH(eh,t,p) :- PossibleEH(eh,t,p), PossibleEH(ehb,t,p), BeforeEH(ehb,eh).
FinalEH(eh,t,p) :- PossibleEH(eh,t,p), !InfeasibleEH(eh,t,p).
