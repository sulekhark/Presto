.include "T.dom"                         # domain of types
.include "F.dom"                         # domain of fields
.include "M.dom"                         # domain of methods
.include "I.dom"                         # domain of invoke statements
.include "H.dom"                         # domain of allocation sites
.include "V.dom"                         # domain of variables
.include "Z.dom"                         # domain of integer indexes
.include "X.dom"                         # domain of addresses for all objects, fields of objects and structs whose address can be taken.

###
# Relations
###

VT(v:V,t:T) input                        # Variable v has Type t
HT(h:H,t:T) input                        # AllocSite h has Type t
cha(n:M,t:T,m:M) input                   # For receiver object of Type t, virtual/interface/overridable Method n resolves to Method m.
sub(t1:T,t2:T) input                     # Type t1 is a subtype of Type t2
MmethArg(m:M,n:Z,v:V) input              # Variable v is the nth parameter of Method m
MmethRet(m:M,n:Z,v:V) input              # Variable v is returned from Method m (n is always 0 - not used).
IinvkArg0(i:I,v:V) input                 # Variable v is the receiver of the method call in the InvokeStmt i
IinvkArg(i:I,n:Z,v:V) input              # Variable v is the nth argument of the method call in the InvokeStmt i
IinvkRet(i:I,n:Z,v:V) input              # Variable v is the lhs of InvokeStmt i (n is always 0 - not used)
MI(m:M,i:I) input                        # Method m contains InvokeStmt i
StatIM(i:I,m:M) input                    # InvokeStmt i calls static method m
VirtIM(i:I,m:M) input                    # InvokeStmt i calls instance method m
DelegateIV(i:I, v:V) input               # Invoke Stmt i makes a call via delegate variable v.

AddrOfMX(m:M,x:X) input                  # Method m has Address x
AddrOfHFX(h:H,f:F,x:X) input             # The Field f of the abstract object allocated at AllocSite h has Address x
AddrOfVX(v:V,x:X) input                  # Variable v has Address x
AddrOfFX(f:F,x:X) input                  # Static field f has Address x

MAlloc(m:M,l:V,h:H) input                # Method m contains stmt: l = new ... (alloc site h)
MMove(m:M,l:V,r:V) input                 # Method m contains: l = r
MInstFldRead(m:M,l:V,r:V,f:F) input      # Method m contains: l = r.f
MInstFldWrite(m:M,l:V,f:F,r:V) input     # Method m contains: l.f = r
MStatFldRead(m:M,l:V,f:F) input          # Method m contains: l = f
MStatFldWrite(m:M,f:F,r:V) input         # Method m contains: f = r

# Assignment instructions where both left and right operands are structs
MStrMove(m:M,l:V,r:V) input              # Method m contains l = r
MStrInstFldRead(m:M,l:V,r:V,f:F) input   # Method m contains: l = r.f
MStrInstFldWrite(m:M,l:V,f:F,r:V) input  # Method m contains: l.f = r
MStrStatFldRead(m:M,l:V,f:F) input       # Method m contains: l = f
MStrStatFldWrite(m:M,f:F,r:V) input      # Method m contains: f = r

MAddrTakenLocal(m:M,l:V,r:V) input       # Method m contains l = &r
MAddrTakenInstFld(m:M,l:V,r:V,f:F) input # Method m contains l = &r.f
MAddrTakenStatFld(m:M,l:V,f:F) input     # Method m contains l = &f
MAddrTakenFunc(m1:M,l:V,m2:M)            # Method m1 contains l = &m2, where m2 is a method.

MDerefLeft(m:M,l:V,r:V) input            # Method m contains *l = r
MDerefRight(m:M,l:V,r:V) input           # Method m contains l = *r

structV(v:V) input                       # Local variable v is of type struct
classT(t:T) input                        # Type t is a class
staticTM(t:T,m:M) input                  # Type t contains static method m
staticTF(t:T,f:F) input                  # Type t contains static field f
clinitTM(t:T,m:M) input                  # Type t contains static initializer method m
entryPtM(m:M) input                      # Method m is an entrypoint

IHM(i:I,h:H,m:M)
VHfilter(v:V,h:H)
DelegateIH(i:I,h:H)
DelReceiver(i:I,h:H)
DelFunc(i:I,m:M)

Alloc(l:V,h:H)
Move(l:V,r:V)
InstFldRead(l:V,h:H,f:F)
InstFldWrite(h:H,f:F,r:V)
StatFldRead(l:V,f:F)
StatFldWrite(f:F,r:V)

StrMove(l:V,r:V)
StrInstFldRead(l:V,h:H,f:F)
StrInstFldWrite(h:H,f:F,r:V)
StrStatFldRead(l:V,f:F)
StrStatFldWrite(f:F,r:V)

AddrTakenLocal(l:V,r:V)
AddrTakenInstFld(l:V,r:V,f:F)
AddrTakenStatFld(l:V,f:F)
AddrTakenFunc(l:V, m:M)
DerefLeft(l:V,r:V)
DerefRight(l:V,r:V)

reachableT(t:T) printtuples
VH(v:V,h:H) printtuples                # Variable v may point to AllocSite h
VX(v:V,x:X) printtuples                # Variable v may point to Address x
FH(f:F,h:H) printtuples                # Static field f may point to AllocSite h
FX(f:F,x:X) printtuples                # Static field f may point to Address x
rootM(m:M) printtuples
HFH(h1:H,f:F,h2:H) printtuples         # Field f of object allocated at AllocSite h1 may point to AllocSite h2
HFX(h:H,f:F,x:X) printtuples           # Field f of object allocated at AllocSite h may point to Address x
reachableI(i:I) printtuples
reachableM(m:M) printtuples
IM(i:I,m:M) printtuples                # InvokeStmt i may call Method m
MM(m:M,n:M) printtuples                # Method m may call Method n

###
# Constraints
###

VHfilter(v,h) :- VT(v,t), HT(h,s), sub(s,t).
IHM(i,h,m2) :- VirtIM(i,m1), HT(h,t), cha(m1,t,m2).

# base cases: each root method and each class initializer is reachable
reachableM(m) :- entryPtM(m).
reachableM(m) :- reachableT(t), clinitTM(t,m).
# inductive case
reachableM(m) :- IM(_,m).

reachableI(i) :- MI(m,i), reachableM(m).

# possibly-multiple-target call sites
IM(i,m) :- reachableI(i), IinvkArg0(i,v), VH(v,h), IHM(i,h,m).
# calls to static methods
IM(i,m) :- reachableI(i), StatIM(i,m).
# method call via delegates
DelegateIH(i,h) :- reachableI(i), DelegateIV(i,v), VH(v,h).
DelReceiver(i,rh) :- DelegateIH(i,h), HFH(h,0,rh).
DelFunc(i,m) :- DelegateIH(i,h), HFX(h,0,x), AddrOfMX(m,x).
IM(i,m1) :- DelFunc(i,m), DelReceiver(i,h), HT(h,t), cha(m,t,m1).
IM(i,m) :- DelFunc(i,m), staticTM(t,m).

# arguments and return/throw variables
Move(v,u) :- IinvkArg(i,z,u), IM(i,m), MmethArg(m,z,v), !structV(u).
Move(u,v) :- IinvkRet(i,z,u), IM(i,m), MmethRet(m,z,v), !structV(u).
StrMove(v,u) :- IinvkArg(i,z,u), IM(i,m), MmethArg(m,z,v), structV(u).
StrMove(u,v) :- IinvkRet(i,z,u), IM(i,m), MmethRet(m,z,v), structV(u).

Alloc(l,h)   :- reachableM(m), MAlloc(m,l,h).
Move(l,r)   :- reachableM(m), MMove(m,l,r).
InstFldRead(l,h,f) :- reachableM(m), MInstFldRead(m,l,r,f), VH(r,h).
InstFldWrite(h,f,r) :- reachableM(m), MInstFldWrite(m,l,f,r), VH(l,h).
StatFldRead(l,f)   :- reachableM(m), MStatFldRead(m,l,f).
StatFldWrite(f,r)   :- reachableM(m), MStatFldWrite(m,f,r).

StrMove(l,r) :- reachableM(m), MStrMove(m,l,r).
StrInstFldRead(l,h,f) :- reachableM(m), MStrInstFldRead(m,l,r,f), VH(r,h).
StrInstFldWrite(h,f,r) :- reachableM(m), MStrInstFldWrite(m,l,f,r), VH(l,h).
StrStatFldRead(l,f)   :- reachableM(m), MStrStatFldRead(m,l,f).
StrStatFldWrite(f,r)   :- reachableM(m), MStrStatFldWrite(m,f,r).

AddrTakenLocal(l,r) :- reachableM(m), MAddrTakenLocal(m,l,r).
AddrTakenInstFld(l,r,f) :- reachableM(m), MAddrTakenInstFld(m,l,r,f).
AddrTakenStatFld(l,f) :- reachableM(m), MAddrTakenStatFld(m,l,f).
AddrTakenFunc(l,m2) :- reachableM(m1), MAddrTakenFunc(m1,l,m2).
DerefLeft(l,r) :- reachableM(m), MDerefLeft(m,l,r).
DerefRight(l,r) :- reachableM(m), MDerefRight(m,l,r).

VH(l,h) :- Alloc(l,h), VHfilter(l,h).
VH(l,h) :- Move(l,r), VH(r,h), VHfilter(l,h).
VX(l,x) :- Move(l,r), VX(r,x).
VH(l,hfh) :- InstFldRead(l,h,f), HFH(h,f,hfh), VHfilter(l,hfh).
VX(l,x) :- InstFldRead(l,h,f), HFX(h,f,x).
HFH(h,f,rh) :- InstFldWrite(h,f,r), VH(r,rh).
HFX(h,f,x) :- InstFldWrite(h,f,r), VX(r,x).
VH(l,h) :- StatFldRead(l,f), FH(f,h), VHfilter(l,h).
VX(l,x) :- StatFldRead(l,f), FX(f,x).
FH(f,h) :- StatFldWrite(f,r), VH(r,h).
FX(f,x) :- StatFldWrite(f,r), VX(r,x).

# handling structs
HFH(lh,f,rhfh) :- StrMove(l,r), VH(r,rh), VH(l,lh), HFH(rh,f,rhfh).
HFX(lh,f,x) :- StrMove(l,r), VH(r,rh), VH(l,lh), HFX(rh,f,x).
HFH(lh,f1,hfhf1h) :- StrInstFldRead(l,h,f), VH(l,lh), HFH(h,f,hfh), HFH(hfh,f1,hfhf1h).
HFX(lh,f1,x) :- StrInstFldRead(l,h,f), VH(l,lh), HFH(h,f,hfh), HFX(hfh,f1,x).
HFH(hfh,f1,rhf1h) :- StrInstFldWrite(h,f,r), VH(r,rh), HFH(h,f,hfh), HFH(rh,f1,rhf1h).
HFX(hfh,f1,x) :- StrInstFldWrite(h,f,r), VH(r,rh), HFH(h,f,hfh), HFX(rh,f1,x).
HFH(lh,f1,fhf1h) :- StrStatFldRead(l,f), VH(l,lh), FH(f,fh), HFH(fh,f1,fhf1h).
HFX(lh,f1,x) :- StrStatFldRead(l,f), VH(l,lh), FH(f,fh), HFX(fh,f1,x).
HFH(fh,f1,fhf1h) :- StrStatFldWrite(f,r), VH(r,rh), FH(f,fh), HFH(rh,f1,rhf1h).
HFX(fh,f1,x) :- StrStatFldWrite(f,r), VH(r,rh), FH(f,fh), HFX(rh,f1,x).

# Handling & operator
# v1 = &v2, v1 = &v2.f, v1 = &f, v1 = &m
VX(v1,x) :- AddrTakenLocal(v1,v2), AddrOfVX(v2,x).
VX(v1,x) :- AddrTakenInstFld(v1,v2,f), VH(v2,h2), AddrOfHFX(h2,f,x).
VX(v1,x) :- AddrTakenStatFld(v1,f), AddrOfFX(f,x).
VX(v1,x) :- AddrTakenFunc(v1,m), AddrOfMX(m,x).

# Handling dereference
# *l = r
Move(v,r) :- DerefLeft(l,r), VX(l,x), AddrOfVX(v,x), !structV(r).
StrMove(v,r) :- DerefLeft(l,r), VX(l,x), AddrOfVX(v,x), structV(r).
InstFldWrite(h,f,r) :- DerefLeft(l,r), VX(l,x), AddrOfHFX(h,f,x), !structV(r).
StrInstFldWrite(h,f,r) :- DerefLeft(l,r), VX(l,x), AddrOfHFX(h,f,x), structV(r).
StatFldWrite(f,r) :- DerefLeft(l,r), VX(l,x), AddrOfFX(f,x), !structV(r).
StrStatFldWrite(f,r) :- DerefLeft(l,r), VX(l,x), AddrOfFX(f,x), structV(r).
# l = *r
Move(l,v) :- DerefRight(l,r), VX(r,x), AddrOfVX(v,x), !structV(l).
StrMove(l,v) :- DerefRight(l,r), VX(r,x), AddrOfVX(v,x), structV(l).
InstFldRead(l,h,f) :- DerefRight(l,r), VX(r,x), AddrOfHFX(h,f,x), !structV(l).
StrInstFldRead(l,h,f) :- DerefRight(l,r), VX(r,x), AddrOfHFX(h,f,x), structV(l).
StatFldRead(l,f) :- DerefRight(l,r), VX(r,x), AddrOfFX(f,x), !structV(l).
StrStatFldRead(l,f) :- DerefRight(l,r), VX(r,x), AddrOfFX(f,x), structV(l).


# 1. T is a class and an instance of T is created.
reachableT(t) :- Alloc(_,h), HT(h,t).
# 2. T is a class and a static method declared by T is invoked
reachableT(t) :- reachableM(m), staticTM(t,m).
# 3. A static field declared by T is assigned.
reachableT(t) :- StatFldWrite(f,_), staticTF(t,f).
# 4. A static field declared by T is used and the reference to the
#    field is not a compile-time constant.
reachableT(t) :- StatFldRead(_,f), staticTF(t,f).
# 5. Before a class is initialized, its direct superclass must be
#    initialized.
reachableT(t) :- classT(t), reachableT(s), sub(s,t).

rootM(m) :- entryPtM(m).
rootM(m) :- reachableT(t), clinitTM(t,m).
MM(m,n) :- IM(i,n), MI(m,i).

.include "cha.datalog"
.include "classT.datalog"
.include "clinitTM.datalog"
.include "entryPtM.datalog"
.include "HT.datalog"
.include "IinvkArg.datalog"
.include "IinvkArg0.datalog"
.include "IinvkRet.datalog"
.include "MAlloc.datalog"
.include "MI.datalog"
.include "MInstFldRead.datalog"
.include "MInstFldWrite.datalog"
.include "MmethArg.datalog"
.include "MmethRet.datalog"
.include "MMove.datalog"
.include "MStatFldRead.datalog"
.include "MStatFldWrite.datalog"
.include "staticTF.datalog"
.include "staticTM.datalog"
.include "StatIM.datalog"
.include "sub.datalog"
.include "VirtIM.datalog"
.include "VT.datalog"
