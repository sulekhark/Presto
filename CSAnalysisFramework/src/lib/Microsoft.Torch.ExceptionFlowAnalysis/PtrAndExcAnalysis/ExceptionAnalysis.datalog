.include "T.dom"                         # domain of types
.include "M.dom"                         # domain of methods
.include "I.dom"                         # domain of invoke statements
.include "H.dom"                         # domain of allocation sites
.include "V.dom"                         # domain of variables
.include "X.dom"                         # domain of addresses for all objects, fields of objects and structs whose address can be taken.
.include "EH.dom"                        # domain of exception handlers
.include "P.dom"                         # domain of program points


# Input Relations
IM(i:I,m:M) input                        # Call-Graph edge: Method m maybe called at invoke stmt i
HT(h:H,t:T) input                        # Allocation site h allocates an object of Type t
VH(v:V,h:H) input                        # Variable v points-to Allocation Site h.
sub(t1:T,t2:T) input                     # Type t1 is a subtype of Type t2
MI(m:M,i:I) input                        # Method m contains InvokeStmt i

InRange(eh:EH,p:P) input                 # An exception raised at Program point P could potentially be caught by ExceptionHandler eh
PrevEH(eh1:EH,eh2:EH) input              # ExceptionHandler eh1 immediately precedes eh2
TypeEH(eh:EH,t:T) input                  # ExceptionHandler eh handles exceptions of Type t
VarEH(eh:EH,v:V)  input                  # ExceptionHandler eh has the formal paramter as Variable v
ThrowPV(p:P,v:V)  input                  # Instruction p throws Variable v


# Intermediate/Output relations
BeforeEH(eh1:EH,eh2:EH)                  # Transitive closure of PrevEH
PossibleEH(eh:EH.t:T,p:P)                # If the instruction at Program point p throws an exception of Type t, ExceptionHAndler eh may catch it.
                                         # Ignores order of the catch blocks.
InfeasibleEH(eh:EH,t:T,p:P)              # It is infeasible for ExceptionHandler eh to catch an exception of Type t thrown at Program point p because
                                         # of ordering i.e. some earlier catch block is catching exceptions of the same type.
FinalEH(eh:EH,t:T,p:P)                   # ExceptionHandler eh catches an exception of Type t thrown at Program point p.
ThrowMH(m:M,h:H)                         # The exception object h escapes Method m.
ThrowVH(v:V,h:H)                         # Variable v which is the formal parameter of some catch handler, points-to exception object h.



#Rules
PossibleEH(eh,t,p) :- InRange(eh,p), TypeEH(eh,t).
PossibleEH(eh,s,p) :- Possible(eh,t,p), sub(s,t).
BeforeEH(eh1,eh2) :- PrevEH(eh1,eh2).
BeforeEH(eh1,eh3) :- BeforeEH(eh1,eh2), PrevEH(eh2,eh3).
InfeasibleEH(eh,t,p) :- PossibleEH(eh,t,p), PossibleEH(ehb,t,p), BeforeEH(ehb,eh).
FinalEH(eh,t,p) :- PossibleEH(eh,t,p), !InfeasibleEH(eh,t,p).

ThrowMH(m,h) :- ThrowPV(p,v), VH(v,h), HT(h,t), !FinalEH(eh,t,p).
ThrowMH(m,h) :- MI(m,i), IM(i,mcallee), ThrowMH(mcallee,h), HT(h,t), !FinalEH(eh,t,i).
ThrowVH(v,h) :- ThrowPV(p,v), VH(v,h), HT(h,t), FinalEH(eh,t,p), VarEH(eh,v).
ThrowVH(v,h) :- IM(i,mcallee), ThrowMH(mcallee,h), HT(h,t), FinalEH(eh,t,i), VarEH(eh,v).
